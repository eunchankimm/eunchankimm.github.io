---
layout : post
title : "데이터베이스 면접준비"
category : 데이터베이스
tag : [취업,데이터베이스]
---

#### RDBMS / NoSQL

**Relational DataBase Management System - 관계형 데이터 베이스 관리 시스템**

관계형 모델을 기반으로 한 데이터 베이스 시스템 입니다.

RDBMS는 행과 열로 구성된 테이블을 최소 단위로 구성되어 있으며,  SQL을 사용하여 쉽게 데이터베이스를 관리 할 수 있습니다. 



NoSQL은 관계형 데이터베이스 보다 덜 제한적인 일관성 모델을 이용하여 , 관계를 정의할 필요가 없고, 그러므로 테이블을 나눌 필요가 없이, 데이터를 저장 검색 할수 있는 데이터 베이스 시스템을 말합니다.

#### SQL

> SQL은 구조적인 질의 언어라는 것이다.
>
> SQL은 관계형 데이터베이스에서 쓰이는 질의 언어로 이를 통해 데이터베이스를 제어 관리한다.



**1) DDL - 데이터 정의 언어**

> DDL(Data Definition Language)은 데이터 베이스 스키마를 정의 하거나 조작하기 위해 사용한다. 

스키마 = 데이터베이스  , 데이터베이스 : 여러 테이블의 합

- 종류

  CREATE : 정의

  ALTER : 수정

  DROP : 삭제

  TRUNCATE : DROP 후 CREATE

**2) DML - 데이터 조작 언어**

> DML(Data Manipulation Language)은 데이터를 조작(조회, 추가, 변경, 삭제) 하기 위해 사용한다. 사용자가 응용 프로그램과 데이터 베이스 사이에 실질적인 데이터 처리를 위해서 주로 사용한다.

- 종류

  SELECT : 조회

  INSERT : 추가

  DELETE : 삭제

  UPDATE : 변경

**3) DCL - 데이터 제어 언어**

> DCL(Data Control Language)는 데이터를 제어하는 언어이다.
>
> 데이터의 보안, 무결성, 회복, 병행 수행제어 등을 정의하는데 사용한다.

- 종류

  COMMIT : 트랜잭션의 작업 결과를 반영

  ROLLBACK : 트랜잭션의 작업을 취소 및 원래대로 복구

  GRANT : 사용자에게 권한 부여

  REVOKE :  사용자 권한 취소




#### 정규화란 - 샤딩

> 데이터를 속성들이 상호 종속적인 관계를 이용하는 것으로, 테이블을 무손실 분해하는 것을 의미
>
> 테이블의 데이터 중복을 최소화 하며, insert, update, delete 때 이상현상 발생 가능성을 줄이는 것

**무손실 분해란** - 테이블 R을 프로젝션인 R1,R2 Natural Join을 통해 원래의 테이블R로 돌아 갈때 정보의 손실 없이 돌아가는 것

NATURAL JOIN

‘=''일 때 동일한 속성이 두 번 나타나게 되는데 이 중 중복된 속성을 제거하여한 번만 표기하는 방법



#### 제 1정규형

> 데이터 셀에 있는 모든 값들을 스칼라 값(원자값)으로 만드는 것을 말합니다
>
> 관계형 데이터베이스의 테이블은 제 1정규형을 자동으로 만족하고 있습니다.



####제 2정규형

> 제 1정규형을 만족하며, 완전 함수적 종속을 만족하는 것을 말합니다.
>
> 함수적 종속이란 예를들어 어떤 기본키로 한 튜플을 식별할 수 있는 것을 말합니다.
>
> 그래서 기본키가 만약 속성 하나로 이루어져 있다면, 함수적 종속을 항상 만족합니다.
>
> 만약 

**부분 함수의 종속**  :  기본키를 구성하는 열의 일부에만 함수 종속이 존재 하는 것



#### 제 3정규형은

>제 1 , 2 정규형을 만족하며, 추이 함수적 종속을 만족하는 것을 말합니다. 
>
>추이 함수적 종속이란 A - > B 이고 B - > C일 떄 A -> C 만족하는 관계를 말합니다.



#### 역 정규화

> 정규화 과정을 통해 나뉘어진 테이블을 다시 합치는 것으로, 만약에 정규화를 통해 여러개로 나뉘어진 테이블이 있는데, 여기서 필요한 데이터를 얻기위해 지나치게 자주 join을 통해 하나의 테이블로 만드는 것은 응답속도가 떨어지므로, 정규화에는 위배되지만, 성능 향상을 위해 다시 테이블을 합치는 것을 말합니다.



#### 데이터 이상

> 테이블의 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고 중복으로 인해 테이블 조작 시 발생하는 문제 

**이상의 종류**

- 삽입 이상

  데이터 삽입 시 원치않은 데이터까지 삽입해야 되는 현상

- 삭제 이상

  테이블에서 튜플 삭제시 , 원치 않는 정보까지 삭제되는 현상

- 갱신 이상

  테이블에서 특정 속성 값을 갱신 했을 때, 중복 저장되어있는 속성일 때, 나머지는 갱신하지 않아, 데이터의 불일치가 발생되는 현상



#### 데이터베이스의 무결성

> 데이터에 적용되는 연산에 제한을 두어, 데이터에 대한 정확성, 일관성, 유효성이 유지되는 것을 말함

- 개체 무결성

  모든 테이블은 기본 키를 가지고 있어야 한다. 기본키는 NULL이여선 안된다.

- 고유 무결성

  특정 속성에 대해 각 튜플이 값는 속성 값들이 서로 달라야 한다.

- 참조 무결성

  외래키 값은 NULL 이거나, 참조 테이블의 기본키 값과 동일해야한다.

- 키 무결성

  하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다.

- 도메인 무결성

  특정 속성 값이 그 속성에 정의된 도메인에 속한 값이여야 한다.



#### Trigger란?

> 테이블에 대한 이벤트에 반응해 자동으로 실행되는 특수한 저장 프로시저를 의미하며 , DML의 데이터 상태의 관리를 자동화하는데 사용된다.



#### data independency

>



#### 뷰 & 서브쿼리 및 결합(JOIN)

**View**

> 하나 이상의 테이블(또는 다른 view)에서 원하는 모든 데이터를 선택하여, 그들을 사용자 정의하여 나타내는 것으로, 여러 테이블 또는 뷰의 데이터를 연결하여 조합할 수 있다.
>
> 실제 테이블과 달리 데이터 자체를 포함하고 있는 것은 아니다. 뷰를 사용하면 여러 테이블이나 뷰를 하나의 테이블인 것처럼 볼 수 있다  

**서브 쿼리**

> 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문을 말한다. 메인쿼리가 서브쿼리를 포함하는 종속적인 관계

```
SELECT * FROM db.table WHERE table_fk {
    SELECT table_fk FROM db_table_ohere where ...
}
```

**결합(join)**

> 두 개 이상의 테이블에 대해 결합조건을 통해 하나의 관계된 테이블로 반환하는것을 말합니다.

- 내부 결합(inner join)

  ```
  SELECT 선택하고 싶은 열 리스트 FROM 첫 번째 테이블 명 INNER JOIN 두 번째 테이블명 ON 결합 조건;
  ```

  2개 이상의 테이블에 대해 결합조건에 연관되면서 조건에 맞는 행들을 하나의 테이블로 표현하는 것

- 외부 결합(Outer join)

  ```
  SELECT 선택하고 싶은 열 리스트 FROM 첫 번째 테이블 명 LEFT OUTER JOIN 두 번째 테이블명 ON 결합 조건;  (left 를 right 로하면 기준이 오른쪽으로 바뀌는것뿐)
  ```

  inner join과는 달리 'ON'에 있는 결합조건에 충족되지 않아도,  기준이 되는 테이블의 행과 다른 테이블의 모든 공통 행을 결합할수 있습니다.

- Cross Join (교차 조인)

  결합조건에 관하여 테이블들의 행 만큼 곱하여 테이블로 표현하는 것

  ​

  ​

#### DB서버의 다중화 - 클러스터링

> 데이터베이스는 DB서버와 저장소로 구성 (DB서버 - 계산이나 업무 로직 처리 , 저장소 - 데이터 보존)
>
> DB서버 만을 다중화하고 하나의 저장소를 하나만 두는 경우는
>
> Active - Active   - 클러스터를 구성하는 컴포넌트를 동시에 가동한다.
>
> Active - Standby  - 클러스터를 구성하는 컴포넌트 중 실제 가동하는 것은 Active ,  남은 것은 대기 Standby 하고 있는다.

#### Active - Active

**장점**

- 시스템 다운 시간이 짧다

  복수의 DB가 동시에 작동하기 때문에 한 대의 DB서버가 다운이 되도. 다른 DB서버가 대신 처리를 계속해 시스템 전체가 정지되는 것을 막을 수 있다.

- 성능이 좋다

  여러개의  DB서버가 동시에 작동하는 것이기 떄문에 여러개의 cpu와 메모리를 동시에 사용하는 것이므로 성능도 향상될 수 있다, **하지만  저장소가 하나기 때문에 병목현상이 발생할 수 있다.**

**단점**

- DB서버를 다중화 하는 것중에 가장 비싸다



#### Active - Standby

- Cold - Standby

  평소에는 Standby 상태의 DB가 작동하지 않다가 , Active 상태의 DB가 다운된 시점에 작동하는 구성

- Hot - Standby

  평소에도 Standby 상태의 DB가 계속 작동 중이다

Standby상태의 DB들은 Active상태의 DB서버에게 **Heartbeat**이라는 신호를 보내 서버가 다운되어있는지 확인

Hot - Standby 쪽이 전환 시간이 짧지만 그만큼 라이센스쇼가 비싸다.



#### DB서버와 데이터의 다중화

- 리플리케이션

  리플리케이션은 DB서버와 저장소 세트를 복수로 준비하는 것을 말함

  만약 한 세트가 지진이나 천재지변으로 다운이 되더라도, 다른 세트를 준비를 미리 해놨기 때문에 바로 서비스를 이어서 할 수 있다. 하지만 데이터를 갱신을 반영하는 최신화를 해야하는데,  갱신 주기에 따라 트레이드오프 관계가 생기기 때문에 적절한 데이터 갱신 주기가 필요하다.

  만약 갱신하지 않은 상태로 Active한 DB서버와 저장소가 다운이 된다면,. 가장 최근에 한 갱신으로 데이터가 저장되는 시점으로 돌아가는데, 그럼 두 사이의 차이 만큼 데이터가 날아가 버리는 것이다.

  리플리케이션은 주로 피라미드 방식이며 , 마스터 슬레이브 방식을 주로 사용합니다.



#### 성능을 추구하기 위한 다중화 

- Shared Disk

  저장소에서 병목현상이 발생하는 것은, 여러개의 DB서버가 한 저장소를 공유하는 것을 Shared Disk라고 하는데, 이는 병목현상이 발생 할 수 있다.

- Shared Nothing

  이름처럼 아무것도 공유하지 않는 것이다. 여러개의 DB서버 와 저장소 세트를 준비해서 , 병렬처리를 통해 선형적으로 성능을 향상 시킬 수 있다. 이를 Google에서 자사가 개발한 Shared Nothing을 **샤딩**이라고 부릅니다.

  만약 어느 한  DB서버가 다운이 되었다면, 다른 서버가 이 서버가 일을 대신 처리해줘야하는 **커버링**구성을 고려해야하는데, 위에 작업을 처리해줄 정리서버도 하나 필요합니다

  ​

  ​



#### 데이터베이스 트랜잭션에 대해 설명, ACID에 대해 설명

> 트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위로, SQL과 같은 질의어
>
> 들이 모여 한 작업의 단위를 말합니다



#### 트랜잭션의 특징 (ACID)

- 원자성 (Atomicity)
- 일관성 (Consistency)
- 독립성 (Isolation)
- 지속성 (Durability)

> 원자성 - 트랜잭션이 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 합니다.
>
> ​             만약 트랜잭션 단위로 데이터가 처리되지 않는다면, 설계한 사람이 데이터의 처리 시스템을          
>
>   	     이해하기 힘들 뿐만 아니라, 오작동시 원인을 찾기 매우 힘듭니다.
>
> 일관성 - 트랜잭션의 작업처리 결과가 항상 일관성이 있어야 합니다.
>
> ​	     트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는 것이 아니라, 처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스로 진행된다. 이렇게 함으로써 각 사용자는 일관성있는 데이터를 볼 수 있다.
>
> 독립성 - 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 경우에 어느 하나의 트랜잭션이라도 다른 트랜잭션의 연산을 끼어들 수 없다.
>
> 지속성 - 트랜잭션이 성공적으로 완료됐을 경우, 결과는 영구적으로 반영되어야 한다. 



#### 키(Key)의 종류와 개념 설명

**1) 슈퍼키**

- 어떤 테이블의 속성의 조합 ( 이 조합으로 테이블 내에서 어떤 튜플을 구분 할 수 있어야 함 )

- 학번이 A11이고 이름이 홍길동인건 테이블에 딱 한 튜플만 존재

  - 학번 + 성명 또는 학번 + 주민번호 또는 학번 + 주민번호 + 성명등 슈퍼키는 튜플을 유일하게 구분할 수 만 있으면 여러개가 존재 할 수 있다  --> 최소성(Minimality)를 만족하지 못하며, 유일성(Unique)은 만족

  | 학번 | 주민등록번호 |  성명  |
  | :--: | :----------: | :----: |
  | A11  |   111-123    | 홍길동 |
  | A12  |   112-162    | 김철수 |
  |  A3  |   172-163    | 박영희 |
  |  A4  |   192-625    | 홍길동 |

  ​

**2) 후보키**

- 슈퍼키 중에서 최소한의 속성의 부분집합만으로도 어떤 한 튜플을 유일하게 구분 (최소성 만족)
- 위에 슈퍼키 (학번 + 성명) 에서 학번속성 만 있어도 어떠한 튜플을 유일하게 구분 가능 --> 최소성
- 후보키 = 유일성(Unique) + 최소성(Minimality)



**3) 기본키**

- 후보키 중에서 하나를 선택한 키
- 예를 들어 학번 또는 주민등록번호는 기본키가 될수 있다
- 학번으로도 튜플을 유일하게 식별 할 수 있고, 주민등록번호로도 튜프을 유일하게 식별 할 수 있음
- 기본키는 NULL값과 중복값을 가질 수 없다
- 기본키가 되지 않은 놈들은 대체키가 됨



**4) 대체키**

- 후보키 중에서도 기본키가 되지 못한 것들



**5) 외래키**

- 다른 릴레이션의 기본키를 참조하는 속성, 또는 속성들의 집합




#### INDEX? index를 쓰는 이유와 장단점

> INDEX란? (풀스캔 , 레인지 스캔) 
>
> 테이블의 레코드(튜플)에 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되어 있는 데이터 구조

장점

- 검색 속도가 아주 빠르다 (풀스캔 -> 레인지 스캔)

단점

- 인데스가 DB공간을 차지하기 때문에 추가적인 공간 필요
- 인덱스를 생성하는 데 시간이 걸림
- 데이터 변경이 자주 일어날 경우 인덱스의 재작성필요 -> 성능에 영향 가능

> 보통 인덱스는 B - TREE (균형 트리)로 구현이됩니다
>
> B - TREE의 균형트리기 때문 데이터의 어떤 튜플을 검색 할때에도 같은 시간에 결과를 얻을 수 있습니다.  균형 트리의 특징으로 데이터 양이 많을 수록 더 높은 효과를 기대 할 수 있습니다.
>
> 하지만 갱신 빈도가 높은 테이블 일 때 인덱스도 정기적으로 재구성 하면서, 인덱스의 균형을 되찾는 작업이 필요하기 때문에 어느정도 오버헤드가 있습니다.
>
> 그래서 트레이드 - 오프를 생각해서 너무 데이터 양이 적을 때에는 풀스캔이 더 성능이 좋을 수 있습니다. (B - TREE 는 정렬된 상태에서 이루어 져야하며, 정렬된 상태의 역할을 기본키가 해줄 수 있다)



semaphore

mutex와 semaphore의 가장 큰 차이점은 관리하는 동기화 대상의 개수이다.

공유된 자원에 지정된 수의 스레드만 진입을 허용하게 한다.

10개의 스레드를 허용하게 했다면, 11번째 스레드는 진입한 10개 중 하나가 일을 마쳐야 들어간다.

지정된 수가 하나이면 Binary Semaphore로 Mutex와 같은 동작을 한다.

정수변수로서 두 개의 표준 원자적(분리되지 않는) 연산 wait()와 signal()로만 수정한다.

바쁜 대기가 없는 세마포어를 위해 block()과 wakeup()을 사용 (monitor의 wait(),pulse())

뮤텍스 : 뮤텍스는 화장실에 들어가기 위한 열쇠로 비유할 수 있습니다. 즉 화장실에 들어갈 수 있는 열쇠를 한 사람이 갖고 있다면, 한 번에 열쇠를 갖고 있는 그 한 사람만이 들어갈 수 있습니다. 화장실에 열쇠를 갖고 있는 사람이 들어가 볼일을 다 본 후에는 줄을 서서 기다리고 있는(대기열-큐) 다음 사람에게 열쇠를 주게 됩니다.  

공식적인 정의(심비안 개발자 라이브러리에서 발췌) : 뮤텍스는 한 번에 하나의 쓰레드만이 실행되도록 하는 재 입장할 수 있는 코드 섹션에 직렬화된  접근이 가능하게 할 때 사용됩니다. 뮤텍스 객체는 제어되는 섹션에 하나의 쓰레드만을 허용하기 때문에 해당 섹션에 접근하려는 다른 쓰레드들을 강제적으로 막음으로써 첫 번째 쓰레드가 해당 섹션을 빠져나올 때까지 기다리도록 합니다. 

뮤텍스는 값이 1인 세마포어입니다. 



세마포어: 세마포어는 빈 화장실 열쇠의 갯수라고 보면 됩니다. 즉, 네 개의 화장실에 자물쇠와 열쇠가 있다고 한다면 세마포어는 열쇠의 갯수를 계산하고 시작할 때 4의 값을 갖습니다. 이 때는 이용할 수 있는 화장실 수가 동등하게 됩니다. 이제 화장실에 사람이 들어갈 때마다 숫자는 줄어들게 됩니다. 4개의 화장실에 사람들이 모두 들어가게 되면 남은 열쇠가 없게 되기 때문에 세마포어 카운트가 0이 됩니다. 이제 다시 한 사람이 화장실에서 볼일을 다 보고 나온다면 세마포어의 카운트는 1이 증가됩니다. 따라서 열쇠 하나가 사용가능하기 때문에 줄을 서서 기다리고 있는 다음 사람이 화장실에 입장할 수 있게 됩니다.



앙 스핀락 으로 다른 락을 구현해